1.Java程序由JVM执行！
2.JVM组成：
	* 类加载器(Class Loader)：负责加载字节码文件(.class)
	* 执行引擎(Execution Engine)：负责执行程序
	* 运行时数据区(Runtime Data Area):负责存储执行程序所需要的数据和相关信息。
3.JAV程序执行过程：
	* Java源代码文件(.java)经过Java编译器变成Java字节码文件(.class)
	* JVM中的类加载器(Class Loader)加载字节码文件，加载完毕后由执行引擎(Execution Engine)执行。
	* 在程序执行的过程中需要用到数据和相关的信息，JVM中的运行时数据区(Runtime Data Area,也叫JVM内存)存储着这些数据和相关信息。
4.运行时数据区的组成：
	* Java栈(VM Stack)
		> 用来存储局部变量(基本数据类型和对象的引用地址,这个引用地址指向实际存对象的堆内存地址)
	 	      例如：A a = new A();//a是变量，存在栈中。new A()是对象，存在堆中。栈中的值是堆内存的地址。通过调用a，使用栈中的值（堆地址）
	 	      而栈中的值又是堆的地址，所以new A()对象就被调用了。
	 	> 每个线程都有一个自己的Java栈，互不干扰。
	* 堆(Heap)
		> Java中堆存储的是数组以及对象本身(对象的引用（是变量）在栈存储)。
		> 堆是被线程共享的，所以只有一个堆
	* 方法区(Method Area)
		> 方法区存储了每个类的信息(类名，成员变量，成员方法,静态变量,静态常量,以及编译后的代码(.class))
		> 方法区中有一个区域叫做运行时常量池(Runtime Constant Pool)，它用来存储常量。
		> 方法去被线程共享的，所以只有一个方法区
		> 方法区没有要求必须实现垃圾回收
	* 本地方法栈(Native Method Stack)
		> 与Java栈类似，只是Java栈存储调用的是Java的方法的数据，而本地方法栈是存数调用本地方法(Native Method)方法的数据。
		      本地方法(Native Method)就是调用操作系统的方法(体现Java平台无关性)。例如在Windows操作系统，它存储的是调用windows方法的数据。
	* 程序计数器(Program Counter Register)
		> 程序计数器也叫PC寄存器。JVM中的程序计数器的功能跟汇编语言中的程序计数器的功能在逻辑上是等同的，也就是说是用来指示执行哪条指令的。
		> 由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，
		      因此，为了能够使得每个线程都在线程切换后能够恢复在切换之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，
		      否则就会影响到程序的正常执行次序。因此，可以这么说，程序计数器是每个线程所私有的。
		> 在JVM规范中规定，如果线程执行的是非native方法，则程序计数器中保存的是当前需要执行的指令的地址；如果线程执行的是native方法，
		      则程序计数器中的值是undefined。
		> 由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。